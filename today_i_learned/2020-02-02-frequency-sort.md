### Frequency Sort (도수정렬)

* 지금까지의 정렬 알고리즘은 두 요소의 키값을 `비교` 했어야 함.
* 하지만 도수 정렬은 요소를 비교할 필요가 없음. (데이터의 비교, 교환 작없 없음)
* if 문, 재귀호출, 이중 for 문 없음. 
* 하지만 도수 (頻度數) 분포표가 필요하기 때문에 데이터의 최솟값과 최댓값을 미리 알고 있는 경우에만 사용 가능. 
* 각 단계의 for문 에서는 배열 요소를 건너뛰지 않고 순서대로 스캔하므로, 같은 값에 대해서 순서가 바뀌는 일이 없음 (= 안정적인 정렬 알고리즘)

* [frequency_sort.c](../frequency_sort.c)

* [Count Sort 관련 포스트](https://blog.shovelman.dev/443)


### 이해하기 

* input 이 숫자 9개인 배열일때 ...  

```
int a [] = {5, 7, 0, 2, 4, 10, 3, 1, 3}; 
```

* 도수 분포를 정리해보면 아래와 같다. 0이란 값은 1번 나오고, 1이란 값은 1번 나오고, ... 3이란 값은 2번 나오고. 
이 예제에서는 아래와 같이 찍힌다. `f[a 의 값] = a의 값 등장 빈도수` 와 같다.   

```
 Frequency Array
f[0] : 1
f[1] : 1
f[2] : 1
f[3] : 2
f[4] : 1
f[5] : 1
f[6] : 0
f[7] : 1
f[8] : 0
f[9] : 0
```

* 이를 누적하는 이유는 정렬을 하기 위함이다. 초등학교때 키를 재면 꼭 `내 앞에 몇 명이나 나보다 작아` 라는 식으로 뽐냈던 기억이 있을 것이다. 
(혹은 그 반대일수도 있지만 ㅜㅜ) 이처럼 a[i] 라는 값 앞에 작은게 몇 개 있는지 알아내고 싶은 것이다. 
* 누적한 배열을 보면 아래와 같다. 

```
f[1] : 2 //0~1까지는 2개의 숫자가 있고 
f[2] : 3 //0~2까지 3개의 숫자가 있고
f[3] : 5 //0~3 까지는 5개의 숫자가 있고 ... 
f[4] : 6 //0~4 까지는 6개의 숫자가 있다 
f[5] : 7 //따라서 5가 올 수 있는 자리는 7번째 칸 부터이다. 
f[6] : 7
f[7] : 8
f[8] : 8
f[9] : 8
f[10] : 9
```

* 보조 배열 b를 만들어서 위의 도수 분포에 따라 값을 넣는다.  
```
b[0] : 0 
b[1] : 1
b[2] : 2
b[3] : 3
b[4] : 3
b[5] : 4  
b[6] : 5 //5라는 값은 배열의 7번째 즉 b[6] 에서부터 채워진다. 
b[7] : 7
b[8] : 10
```

* 위의 b 배열 결과를 원래 배열에 복사해서 넣어주면 정렬이 끝난다. 

```
Sorted in ascending order ...
x[0] : 0
x[1] : 1
x[2] : 2
x[3] : 3
x[4] : 3
x[5] : 4
x[6] : 5
x[7] : 7
x[8] : 10
```
