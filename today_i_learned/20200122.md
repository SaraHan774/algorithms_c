### Quick Sort 
1. 각 그룹에 대해 pivot 을 설정하고 
2. 그룹 나눔을 반복하며 
3. 모든 그룹이 1명이 되면 정렬을 마친다. 

* 예를들어 학생들을 키 순서로 정렬한다고 할 때 
    * pivot 을 키가 168인 학생으로 정한다면 
    * 키가 168이하인 그룹과 168이상인 그룹으로 나뉘고 
    * 이 그룹이 다시 또 155 이상, 이하인 그룹 & 170이상, 이하인 그룹으로 나뉜다. 
    * 그룹을 더 이상 나눌 수 없을 때까지, 즉 1명씩만 "그룹" 에 남을 때 까지 이 과정을 반복한다. 
    * 정렬을 마친다. 
    
* 다음과 같은 배열이 있다고 하자 

```
5 7 1 4 6 2 3 9 8

이 때 6을 pivot 으로 잡는다 하면 6보다 큰 숫자는 오른쪽에, 작은 숫자는 왼쪽에 와야 한다. 

가장 왼쪽의 숫자를 pl이라는 인덱스로 가리키고, 오른쪽의 인덱스를 pr 이라 하자. 

최초의 pl = 5 이고 pr 은 8이다. 6을 기준으로 알맞게 나누어져 있으므로 pl과 pr 을 안쪽으로 한 칸 이동한다. 

이동 후 pl = 7 이고 pr 은 9이다. 

pr은 위치가 알맞으나, pl은 6의 오른쪽에 위치해야 한다. 

따라서 pl은 그대로 두고, pr은 한 칸 안쪽으로 이동한다. 

pl = 7이고 pr = 3 인 상황이 된다. 

양 쪽 모두 6을 기준으로 오른쪽, 왼쪽이 뒤바뀐 상황이므로 두 숫자를 교환한다. 

이 과정을 반복하다 보면 pl 과 pr 의 인덱스가 교차하는 상황이 생긴다. 

pl 과 pr이 교차하면 그룹을 나누는 과정이 끝나고 배열은 a[0] ... a[pl - 1] 과 a[pr + 1] ... a[n-1] 두 개로 나뉘어 지게 된다. 
``` 

* Partition 함수 
    * [partition.c](../partition.c)

```
//배열을 나누는 함수
void partition(int a[], int n){
    //pivot 이상의 그룹과 이하의 그룹으로 나누는 프로그램

    int pivot = n/2;
    int pl = 0;
    int pr = n - 1;

    do{
        while(a[pl] < a[pivot]){
            pl++;
        }
        while(a[pr] > a[pivot]){
            pr--;
        }

        if(pl <= pr){
            swap(int, a[pr], a[pl]);
            pl++;
            pr--;
        }

        //인덱스가 서로 교차하지 않을 동안
    }while(pl <= pr);


    for(int i = 0; i < n; i++){
        if(i == pivot){
            printf("(PIVOT) a[%d] : %d \n", i, a[i]);
        }else{
            printf("a[%d] : %d \n", i, a[i]);
        }
    }
}
```

* 위의 partitioning 과정을 재귀적으로 계속해서 해 나가면 퀵 정렬이 된다. 
* 요소 개수가 1개인 그룹은 더 이상 그룹을 나눌 필요가 없으므로 요소의 개수가 2개 이상인 그룹만 나누면 된다. 

```
1. pr이 a[0] 보다 오른쪽에 있으면 (가장 왼쪽의 요소 인덱스 < pr) 왼쪽 그룹을 나눈다. 
2. pl이 a[n-1] 보다 왼쪽에 있으면 (pl < 가장 오른쪽의 요소 인덱스) 오른쪽 그룹을 나눈다.  
```

* 퀵 정렬은 8퀸 문제와 마찬가지로 분할 정복 알고리즘이므로 재귀 호출을 사용하여 구현할 수 있다. 
* quick 함수는 배열a, 나눌 구간의 첫번째 요소 (left), 마지막 요소(right) 의 인덱스를 매개변수로 받는다. 
* [quick_sort.c](../quick_sort.c)

### Shell Sort 223 페이지 12번 문제 
* [223_Q12.c](../223_Q12.c)
* 요소의 이동 횟수를 비교하려 삽입이 일어나는 for 문 안에 count 변수를 넣어서 측정 
* 1000 개의 데이터로는 version 2 가 더 많은 삽입이 일어남. 
* 하지만 10만개 데이터로는 version 2 의 연산 속도가 60프로 빠름. 