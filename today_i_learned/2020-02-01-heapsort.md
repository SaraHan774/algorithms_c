### Heap Sort

* 개념 
    * heap 의 사전적 정의는 "무언가를 쌓아놓은 더미"
    * 힙 정렬은 힙을 사용하여 정렬하는 알고리즘 
    * Heap 은 부모의 값이 자식의 값보다 항상 크다는 조건을 만족하는 완전이진트리. 
    * 완전 이진트리 : "완전" = 왼쪽부터 자식을 추가하는 모양을 유지, "이진" = 부모가 가질 수 있는 자식의 개수는 최대 2개. 
    * 힙의 가장 위쪽에 있는 노드가 루트, 가장 큰 값을 가진다. 
    
```
트리의 맨 위에서부터 왼쪽 -> 오른쪽 방향으로 순회하며 배열에 넣는다. 

(예시)
배열 {10, 9, 5, 8, 3, 2, 4, 6, 7, 1} 
```

* 부모와 자식의 인덱스 사이에 다음과 같은 관계가 성립 

```
1. 부모는 a[(i-1)/2]
2. 왼쪽 자식은 a[i * 2 + 1]
3. 오른쪽 자식은 a[i * 2 + 2]
```

* 힙 정렬 
    * 힙 정렬은 "가장 큰 값이 루트에 위치"하는 특징을 이용하는 정렬 알고리즘. 
    * 힙에서 가장 큰 값인 루트를 꺼내는 작업을 반복하고, 그 값을 늘어놓으면 배열은 정렬을 마치게 됨. 
    * 힙 정렬은 선택 정렬을 응용한 알고리즘
    * 힙에서 가장 큰값인 루트를 꺼내고 남은 요소에서 가장 큰 값을 다시 구함. 
    * 나머지 요소들이 힙의 형태를 유지할 수 있도록 재구성 필요. 
    
* 루트를 없애고 힙 상태 유지하기 
```
1. 맨 끝의 자식 노드를 루트로 올린다. 
2. 규칙에 맞게 힙을 구성한다.
    1. 큰 값을 가지는 자식과 위치를 바꾼다. 
    2. 이 과정을 재귀적으로 수행한다.
    3. 자식의 값이 작거나, 잎에 다다르면 작업이 종료된다.    
```

* 힙 정렬 알고리즘 살펴보기 
    a. 힙의 루트에 있는 가장 큰 값을 꺼내 배열의 마지막 요소와 바꾼다. 
    b. 가장 큰 값을 끝으로 옮기면 a[last] 는 정렬을 마치게 된다. 나머지 a[0] ~ a[last - 1] 요소들을 힙으로 만든다. 
    그 결과 두번째로 큰 요소가 힙의 루트에 위치하게 된다. 힙의 루트를 꺼내 아직 정렬하지 않은 부분의 마지막 요소인 a[last - 1] 과 바꾼다. 
    c. 위의 과정을 반복하면 배열의 마지막부터 큰 값이 차례대로 대입된다. 

* 과정    
```
1. 변수 i의 값을 n-1로 초기화한다. 
2. a[0]와 a[i]를 바꾼다. 
3. a[0], a[1] ... , a[i-1]을 힙으로 만든다. 
4. i의 값을 1씩 감소시켜 0이 되면 끝난다. 그렇지 않으면 2번 단계로 돌아간다. 
```

* 힙 정렬의 시간 복잡도 
    * 선택 정렬을 응용 
    * 단순 선택 정렬은 정렬되지 않은 영역의 모든 요소를 대상으로 가장 큰 값을 선택
    * 힙 정렬에서는 첫 요소를 꺼내는 것 만으로 가장 큰 값이 구해지므로 첫 요소를 꺼낸 후 나머지 요소들을 다시 힙으로 만들어야 
    그 다음에 꺼낼 첫 요소도 가장 큰 값을 유지함. 
    * **따라서 단순 선택 정렬에서 가장 큰 요소를 선택할 때의 시간 복잡도 O(N) 을 한 번에 선택할 수 있어 O(1)으로 줄어듦.**
    * 그 대신 힙 정렬에서 **다시 힙으로 만드는 작업의 시간 복잡도는 O(logN)임.**  
    
```
*** 
단순 선택정렬은 전체 시간복잡도가 O(N^2), 힙 정렬은 O(N * logN)
***
```

    




