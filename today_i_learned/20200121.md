### Binary Insertion Sort ...이해하기  
* binary search 알고리즘을 통해서 요소를 삽입할 위치를 알아낸다.
* 찾은 요소를 반환하는 것이 아니라 주어진 배열에 target 이 어느 인덱스에 들어갈지, 그 인덱스를 반환.  

```
int binary_search(int a[], int target, int low, int high){
    if(high <= low){
    //Case 1 : high 와 low 가 엇갈려 있거나 같은 위치에 있다면 
    // mid 를 계산하는 것이 의미가 없으므로 곧바로 반환한다
        if(target > a[low]){
            return (low + 1); //low 의 다음 인덱스에 삽입하겠다
        }else{
            return low; //만약 target 이 a[low]보다 작거나 같으면 해당 위치에 삽입하겠다. 
            //어차피 low 는 여기서 배열의 최소값이므로 이 블럭이 실행되는 경우 자동으로 target 이 최소값이 된다. 
        }
    }
    //Case 2 : 만약 mid 를 계산할 수 있다면 
    int mid = (low + high)/2;
   
    //target 과 a[mid]의 위치를 비교한다.
    //Case 2-1 : 만약 a[mid]와 같으면 곧바로 반환한다.  
    if(target == a[mid]){
        return mid + 1; //a[mid]의 다음 인덱스에 삽입하겠다. 
    }
    
    //Case 2-2 : 만약 target 이 mid 보다 더 크면 
    if(target > a[mid]){
        //재귀적으로 범위를 줄여서 (mid + 1) 을 low 로 잡아 검색을 수행한다. 
        return binary_search(a, target, mid + 1, high); 
    }

    //Case 2-3 : 만약 target 이 mid 보다 작으면 
    //재귀적으로 범위를 줄여서 high 를 mid - 1로 잡아 검색을 수행한다. 
    return binary_search(a, target, low, mid - 1); 
}

```

* 탈출하는 조건은 high 와 low 가 엇갈리거나 같은 위치에 있을 때 
    1. target 이 a[low] 보다 크면 low + 1 인덱스를 반환 
    2. target 이 a[low] 보다 작거나 같은 경우 low 인덱스를 반환 (low 는 배열 최소값의 인덱스 이므로)
* high 와 low 가 한번에 엇갈리거나 같은 위치에 않았지만, mid 를 도입했을 때 taget == a[mid] 인 경우


