### 반성 ... 
알고리즘을 잘 해야 내가 원하는 좋은 앱도 만들 수 있건만. 왜 이렇게 알고리즘만 하려 앉으면 안드로이드 생각만 나는지 모르겠다. 
(아니 사실 왜 이런지 매우 잘 안다) 제발 정신 차리고 1일 1알고리즘 실천하자. 나중에 밥은 벌어 먹고 살아야 할 거 아니니.
형베시때 B+ Tree 한테 발리고 나서도 정신을 덜 차렸나보다... 

### Straight Selection Sort 
* 단순 선택 정렬
* 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬한다. 
* 과정 
    1. 아직 정렬하지 않은 부분에서 `a[min]` 을 선택한다.
    2. `a[min]`과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환한다.
    
```
void selection(int a[], int n){
    int i, j; 
    for(i = 0; i < n - 1; i++){
        int min = i; 
        for(j = i + 1; j < n; j++){
              if(a[j] < a[min]){
                min = j; 
            }
        }
        swap(int, a[i], a[min]);
    }
}

```  
* 이 정렬 알고리즘은 서로 떨어져 있는 요소를 교환하는 것이기 때문에 안정적이지 않다. 

### Straight Insertion Sort 
* 단순 삽입 정렬 
* 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 '삽입하는' 작업을 반복해 정렬하는 알고리즘. 
* 단순 삽입 정렬은 2번째 요소부터 선택하여 진행한다. 

```
6 4 1 7 3 9 8 
//두번째 요소인 4를 6과 교환 
4 6 1 7 3 9 8 
//세번째 요소인 1을 앞으로 삽입 
1 4 6 7 3 9 8
//네번째 요소인 7을 앞으로 삽입 - 그러나 바뀌지 않는다. 
1 4 6 7 3 9 8 

//다섯번째 요소인 3을 삽입하는 과정 
1. 7과 3을 비교한다 
2. 7이 3보다 크므로 3의 자리에 7을 넣는다
    
    1 4 6 7 3 9 8 
    1 4 6 7 7 9 8 

3. 6과 7을 비교한다 
4. 6은 3보다 크므로 3보다 뒤에 와야 - 자리를 만든다.

    1 4 6 6 7 9 8 

5. 4는 3보다 크므로 3보다 뒤에 와야 한다. 

    1 3 4 6 7 9 8 

6. 1 은 3보다 작으므로 멈춘다.  

```

* 다시 말해 tmp 에 a[i] 를 대입 (3을 선택) 하고, 
* 반복 제어용 변수 j = i - 1 을 하여서 아래의 두 조건 중 하나를 만족할때까지 j 를 1씩 감소하며 대입하는 작업을 반복한다. 

```
1. 정렬된 열의 왼쪽 끝에 도달한다. (3이 가장 작은 경우)
2. tmp 보다 작거나 같은 key 를 갖는 항목 a[j]를 발견한다. 
```

* 이 때 드모르간의 법칙을 적용하면 아래의 두 조건이 모두 성립할 때까지 반복한다고 할 수 있음 

```
1. j 가 0보다 크다. 
2. a[j-1] 의 값이 tmp 보다 크다. 
```

* 단순 삽입 정렬 예시 
* [214 페이지 예시](../214_inserton_sort.c)

```
void insertion(int a[], int n){

    int i, j;

    for(i = 1; i < n; i++){
        //삽입 정렬은 두번째 요소부터 비교를 시작한다.
        int tmp = a[i];
        //비교 기준이 되는 숫자를 tmp 에 저장한다. 
        for(j = i - 1; j > 0 && a[j-1] > tmp; j--){
            //a[i] 보다 앞의 요소부터 비교를 시작한다 
            //j > 0 보다 커야만 하며, 
            //a[j-1]가 tmp보다 작거나 같으면 비교가 중단된다. 
            a[j] = a[j-1];
        }
        a[j] = tmp;
    }
}
```

### 216페이지 10번 문제 
* 단순 삽입 정렬은 배열의 요소 개수가 많아질수록 요소 삽입에 필요한 비교, 대입 비용이 무시할 수 없을 정도로 커진다. 
* 이 때 배열에서 이미 정렬된 부분은 이진 검색을 사용할 수 있기 때문에 삽입할 위치를 더 빨리 찾을 수 있다. 
* 이진 검색을 사용해 프로그램을 수정하라. 

* [Binary Insertion Sort](../216_Q10.c)
    * 아직 Binary Sort 구현 방식이 잘 이해가 안됨...
    
* Testing Result 

```
Enter Num of Elements :10
 Enter a[0] :34 // => 10개의 숫자 아무거나 입력 
 Enter a[1] :2
 Enter a[2] :2
 Enter a[3] :56
 Enter a[4] :3
 Enter a[5] :32
 Enter a[6] :67
 Enter a[7] :3
 Enter a[8] :23
 Enter a[9] :12
 pos : 0 //pos => Insertion 이 일어나는 위치 
pos : 1
pos : 3
pos : 2
pos : 3
pos : 6
pos : 2
pos : 4
pos : 4
a[0] : 2 // => 정렬 결과 
a[1] : 2
a[2] : 3
a[3] : 3
a[4] : 12
a[5] : 23
a[6] : 32
a[7] : 34
a[8] : 56
a[9] : 67
```
